---
title: "Biostatistical Computing, PHC 6068"
subtitle: "Basics about R"
author: Zhiguang Huo (Caleb)
date: "Wednesday August 23, 2017"
output:
  slidy_presentation: default
  ioslides_presentation: default
  beamer_presentation: null
---

Installation of R, R studio and R markdown
===


How did I learn R?
===
- Take a very simple R course
- Get involved in a data analysis project and use R extensively
- Ask senior students and collegues for help
- Rely on your best friend -- Google


Data types
===

- Basic data types in R: logical, integer, double, character.      
    * use typeof() function to check type of a variable.
    
    


logical
===

- TRUE/T
- FALSE/F

```{r}
if(T){
  print(TRUE)
}

typeof(FALSE)

is.logical(T)
```


integer
===

- 1:10 represents integer sequence 1 to 10.
```{r}
aseq <- 1:10
typeof(aseq)
```
- 6L represents 6 is an integer.

```{r}
aint = 6L
is.integer(aint)
```
- In R, 6 generally is double instead of integer.

```{r}
is.integer(6)
```


double
===

```{r}
typeof(1.4142)
is.double(pi)
is.double(0L)
is.double(0L + 1.5)
```


character
===

- You can create character using single quotes or double quotes

```{r}
acharacter <- "I like Biostatistical computing"
typeof(acharacter)

bcharacter <- "You like Biostatistical computing"
is.character(bcharacter)
```

- When a single quote is part of your string, you need to use double quotes.

```{r}
ccharacter <- "He doesn't like Biostatistical computing"
print(ccharacter)
```


1d Vector
===

- Vector is the basic data structure in R. Two types of vectors
    * Atomic vector: All elements of an atomic vector must be the same type
    * List: elements of a list can be of different type.
- Atomic vectors usually created with c(), short for combine
    * dbl_var <- c(1, 23.1, 4.2)
    * int_var <- c(1L, 11L, 6L)
    * log_var <- c(TRUE, FALSE, T, F)
    * chr_var <- c("I", "like Biistatistical computing")


Vector Functions
===


| Functions 	| Meaning 	|
|---	|---	|
|length(x)  |  Number of elements in x |
|unique(x)  | Unique elements of x   |
|sort(x)  |  Sort the elements of x |
|rev(x)   | Reverse the order of x   |
|names(x)   |  Name the elements of x |
|which(x)   | Indices of x that are TRUE   |
|which.max(x)   |  Index of the maximum element of x |
|which.min(x)   |  Index of the minimum element of x |
|append(x)  |  Insert elements into a vector |
|match(x)   |  First index of an element in a vector |
|union(x, y)  |  Union of x and y |
|intersect(x, y)  |  Intersection of x and y |
|setdiff(x, y)  |  Elements of x that are not in y |
|setequal(x, y)   | Do x and y contain the same elements |                         



Example of Vector Functions
===

```{r}
avec <- c(5,2,9,3)
length(avec)
sort(avec)
rev(avec)
```


Statistical Vector Functions
===

| Functions 	| Meaning 	|
|---	|---	|
|sum(x) |  Sum of x |
|prod(x)  | Product of x |
|cumsum(x)  |  Cumulative sum of x|
|cumprod(x) | Cumulative product of x|
|min(x) | Minimum element of x|
|max(x) | Maximum element of x|
|pmin(x, y) |  Pairwise minimum of x and y |
|pmax(x, y) | Pairwise maximum of x and y |
|mean(x) |  Mean of x |
|median(x) |  Median of x |
|var(x) |  Variance of x |
|sd(x) |  Standard deviation of x |
|cov(x, y) |  Covariance of x and y |
|cor(x, y) |  Correlation of x and y |
|range(x) |  Range of x |
|quantile(x) |  Quantiles of x for given probabilities |
|summary(x) |  Numerical summary of x |


Example of Statistical Vector Functions
===

```{r}
avec <- c(5,2,9,3)
max(avec)
which.max(avec)
mean(avec)
range(avec)
```



Coercion
===

- All elements of an atomic vector must be the same type. Otherwise they will be **coerced** to the most flexible type.
- Types from least to most flexible are: logical, integer, double and character.

```{r}
typeof(c("a", 1))
x <- c(FALSE, FALSE, TRUE)
as.numeric(x)
as.character(x)
typeof(c(1.2,1L))
```


Missing value
===

- Missing values are denoted by NA, which is logical vector of length 1.
- NA will always be coerced to be the correct type if used inside c()
- (optional) You can create NA of a specific type with NA_real_, NA_integer_, NA_character_
```{r}
typeof(NA)
typeof(NA_integer_)
typeof(NA_real_)
typeof(NA_character_)
```



list
===

- Lists are different from atomic vectors because their elememts can be of any type, including lists.
- Construct lists by using list()      
- str() function (short for structure) and gives a compact description of any R data structure.

```{r}
x <- list(1:3, "a", c(TRUE, FALSE, TRUE), list(2.3, 5.9))
str(x)
```



Data structure
===
- Can be organised by their dimensionality (1d, 2d, or nd) and whether they are homogeneous or heterogeneous.

| | Homogeneous 	| Heterogeneous 	|
|---  |---	|---	|
|1d |  Atomic vector | List |
|2d  | Matrix | Data frame |
|nd | Array |  |
- Note there is no 0-dimensional in R, or scalar types. Individual numbers or strings are acutally vector of length one.

More on characters
===
- some special characters:
    * " " for space
    * "\n" for newline
    * "\t" for tab
```{r}
sentenses <- "R is a great statistical software.\n\nWe use R in Biostatistical computing class!"
sentenses
```
- cat function will recognize these special characters and print to the console:
```{r}
cat(sentenses)
```


convert to upper case or lower case
===
```{r}
achar <- "this is a dog."
print(achar)
print(toupper(achar))


print(tolower("WWW.UFL.EDU"))
```


length of a string
===
- use nchar to count how many characters in a string instead of length
```{r}
achar <- "this is a dog."
nchar(achar)
length(achar)
```


vectorizes nchar
===
- we can pass a vector of character to nchar
```{r}
chars <- c("a dog", "a cat", "a gator")
nchar(chars)
length(chars)
```


obtaining a substring
===
- take a sub-sequence of characters --  use substr(), short for sub string.
```{r}
chars <- "this is a dog"
substring(chars,1,1)
substring(chars,11,13)
```

- replace with sub-string.
```{r}
substring(chars,11,13) <- "cat"
print(chars)
```


strsplit
===
- you can split a string by a certain pattern using strsplit() function
```{r}
strsplit("this is a dog", split=" ")
strsplit("this is a dog", split="")
```
- Note the return type is a list with only one element. strsplit can be also vectorized.
```{r}
strsplit(c("this is a dog", "this is a cat", "this is a gator"), split=" ")
```


paste
===
- paste multiple strings
```{r}
paste('this','is','a','dog', sep=" ")
paste0('this','is','a','dog')

avec <- c('this','is','a','dog')
nchar(avec)
paste('this','is','a','dog', collapse = " ")
```


substituation
===

- use gsub to replace certain pattern within a string.

```{r}
achar <- "this is a dog"
gsub("dog","cat",achar) ## pattern, replacement, x
gsub(pattern = "dog",replacement="cat",x=achar) ## pattern, replacement, x
```

- vectorize
```{r}
chars <- c("this is a dog", "this is a cat", "this is a gator")
gsub("this","that",chars) ## pattern, replacement, x
```


Regular expression
===
- A regular expression or regex is a structured string to match specific patterns in the text.
- grep() function allows us to scan through a vector against regex

```{r}
chars <- c("this is a dog", "this is a cat", "this is a gator")
grep("gator", chars)
grep("this", chars)
```


Regular expression 2
===
- match dog or cat
```{r}
chars <- c("this is a dog", "this is a cat", "this is a gator")
grep("dog|cat", chars)
```


Metacharacters
===

- **Metacharacters** are special characters with a special meaning.
- Square braces are used to match anything in the braces
```{r}
chars <- c("this is a dog", "this is a cat", "this is a gator")
grep("[bced]", chars)
```
- dash inside square braces is used to indicate a range
```{r}
chars <- c("this is a dog", "this is a cat", "this is a gator")
grep("[b-d]", chars)
grep("[0-9]", chars)
```


Metacharacters 2
===
- "[:alnum]" matches any alphanumeric character, same as "[a-zA-Z0-9]"
- "[:punct:]" matches to any punctuation mark
- "[:space:]" matches to any white space character (tab and line break).
- A caret inside braces matches anything except the followng words.
    - "[^0-9]" matches anything but a number between 0 and 9.
    - "[^aeiou]" matches anything but a lower case vowel.
- A period "." matches to any character.

Loop
===
- for loop
```{r}
for(i in 1:10){
  cat(i," ")
}
```

- while loop
```{r}
i <- 1
while(i <= 10){
  cat(i," ")
  i <- i + 1
}
```


Attributes
===

- Use to store meta-data.     
- can be accessed individually with attr() or attributes().
- construct a new object with attributes using structure() function  e.g. 
    - structure(1:10, myAttribute="this is a vector") 
```{r}
y <- 1:10
attr(y, "my_attribute") <- "This is a vector"
attr(y, "my_attribute")
attributes(y)
```

Attributes 2
===
- Three special attributes have a specific accessor function to get and set values.
    - names(): a character vector giving each element a name.
    - dim(): used to turn vectors into matrics and arrays.
    - class(): used to implement the S3 object system.
    
```{r}
y <- c(a=1,2:10)
names(y)
names(y)[2] <- 'b'
dim(y)
dim(y) <- c(2,5)
print(y)
class(y)
```
\end{frame}


factor
===

- A factor is a vector that only contain predefined values.
- Factors are used to store categorical data.
- Factors are built on top of character vectors using two attributes:
    - class(), "factor", which makes them behave differently from regular character vectors. 
    - levels(), which defines the set of allowed values.

```{r}
x <- factor(c("a", "b", "b", 'a'))
x
class(x)
levels(x)
```


Matrices
===
- Adding a dim() attribute to an atomic vector
```{r}
a <- matrix(1:6, ncol=3, nrow=2)
c <- 1:6
dim(c) <- c(3,2)
c
dim(c) <- c(2,3)
c
```


Data frames
===
- A data frame is a very popular way of storing data in R.
- A data frame is a list of equal length vector and shares properties of both matrix and list.
    - names() and colnames() are the same thing
    - length() and ncol() are the same thing
    
```{r}
df <- data.frame(x=1:3, y=c("a","b","c"),z=0)
str(df)
cat(names(df), "same as", colnames(df))
cat(length(df), "same as", ncol(df))
```

Data frames 2
===

- data.frame()'s default behaviour turns strings into factors.
    - Use stringsAsFactors = FALSE to suppress
    - or globally set options(stringsAsFactors=FALSE)

```{r}
df1 <- data.frame(x=1:3, y=c("a","b","c"),z=0)
str(df1)

df2 <- data.frame(x=1:3, y=c("a","b","c"),z=0, stringsAsFactors=FALSE)
str(df2)
```

Subsetting -- Atomic vectors
===

- example: x <- c(2.1, 4.2, 3.3, 5.4). How can we obtain a subset of this vector?
    - Positive integers: return elements at the specified position.
    - Negative integers: omit elements at the specified positions.
    - Logical vectors: select elements where the corresponding logical value is TRUE.
    - Nothing: return the original vector.
    - Zero: return a zero length vector.
    - Character vectors: to return elements with matching names.


Subsetting -- Atomic vectors 2
===
```{r}
### subseting
## atomic vectors
x <- c(2.1, 4.2, 3.3, 5.4)

# Positive integer
x[c(3,1)]
order(x)
x[order(x)]
x[c(1,1,1)]
x[c(2.1, 2.9)]

# negative integer
x[-c(1, 3)]

# logical vector
x[c(TRUE, TRUE, FALSE, FALSE)]
x > 3
x[x > 3]
x[c(TRUE, TRUE, NA, FALSE)]

# nothing
x[]

# zero
x[0]
```

Subsetting -- Matrices and arrays
===

- 1d index for each dimension, separated by comma
```{r}
a <- matrix(1:9, nrow=3)
colnames(a) <- c("A","B","C")
a
a[1:2,]
a[c(T,F,T), c("B","A")]
a[,-2]
```


Subsetting -- Data frame
===
- Data frames possess the characteristics of both lists and matrices.
```{r}
options(stringsAsFactors = FALSE)
df <- data.frame(x=1:2, y=2:1, z=letters[1:2])
df[df$x==2,]
df[c("x","z")] # like a list
df[,c("x","z")] # like a matrix
```

Subsetting -- simplifying vs preserving
===
- two types of subsetting: simplifying and preserving subsetting.
    - Simplifying subsets returns the simplest possible data structure that can represent the output.
    - Preserving subsetting keeps the structure of the output the same as the input.

| Functions 	| simplifying 	| preserving | 
|---	|---	|---  |
| List | x[[1]] | x[1] |
| Vector | x[[1]] | x[1] |
| Factor | x[1:2, drop=T] | x[1:2] |
| Data frame | x[,1] or x[[1]] | x[, 1, drop=F] or x[1] |         
         
         
Matching
===
```{r}
grades <- c(1,2,2,3,1)
info <- data.frame(grade=3:1, desc=c("Excellent", "Good", "Poor"), fail=c(F,F,T))
id <- match(grades, info$grade)
id
info[id,]
```


How to get help?
===

- ? your function
    - ?mean
- check with best friend -- google


R markdown
===

- R Markdown provides an authoring framework for data science. You can use a single R Markdown file to:
   - save and execute code
   - generate high quality reports that can be shared with your advisor
   - reproduce your result
   - Homeworks/exam/final project should be finished using R Markdown.
- Now time to demonstrate R Markdown in R studio

R markdown cheatsheet: [https://www.rstudio.com/wp-content/uploads/2015/02/rmarkdown-cheatsheet.pdf](https://www.rstudio.com/wp-content/uploads/2015/02/rmarkdown-cheatsheet.pdf)



References
===

- [http://adv-r.had.co.nz](http://adv-r.had.co.nz)
- [http://www.stat.cmu.edu/~ryantibs/statcomp/](http://www.stat.cmu.edu/~ryantibs/statcomp/)
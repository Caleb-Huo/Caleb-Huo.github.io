---
title: "Biostatistical Computing, PHC 6068"
author: "Zhiguang Huo (Caleb)"
date: "Monday September 6, 2017"
output:
  slidy_presentation: default
  ioslides_presentation: default
  beamer_presentation: null
subtitle: Vectorized calculation
---

Why do we need vectorized calculation (motivating example 1)
===
- Elegant and efficient
- R is slow in loops but fast for vectorized calculation.
```{r}
a <- 1:1000000
### version A, loop
start <- Sys.time()
meanA <- 0
for(i in seq_along(a)){
  meanA <- meanA + a[i]/length(a)
}
end <- Sys.time() 
end - start
meanA

### version B, vectorized calculation
start <- Sys.time()
mean(a)
end <- Sys.time() 
end - start

```


Why do we need vectorized calculation (motivating example 2)
===
- Elegant and efficient
- R is slow in loops but fast for vectorized calculation.
```{r}
a <- 1:1000000
b <- 1000000:1
### version A, loop
start <- Sys.time()
result <- numeric(length(a)) ## create a vector with length length(a) and all elements 0
for(i in seq_along(a)){
  result[i] <- a[i] + b[i]
}
end <- Sys.time() 
end - start

### version B, vectorized calculation
start <- Sys.time()
result <- a + b
end <- Sys.time() 
end - start
```

Simple examples of vectorized calculation
===
- vector algebra
```{r}
a <- c(1.1,3.4,9.5)
b <- c(9,2,0.8)
a + b ## vector addition
a * b ## vector multiplication
a ^ b ## 1.1^9, 3.4^2, 9.5^0.8

```
  

Simple examples of vectorized calculation 2
===
- vector with scalor
```{r}
a <- 1:8
a + 2
a + c(0,1)
a + c(1,2,3) ## warming message 
```


Other scientific calculation
===
```{r}
a <- seq(1,3,1)
sin(a)
tan(a)
log(a,base = 10)
log10(a)
exp(a)
```


vectorized input for plot
===
- all vector input
```{r}
plot(x = 1:10, y = 1:10, col=1:10)
```

- vector input + scalor input
```{r}
plot(x = 1:10, y = 1:10, col=1)
```

Initialize a vector
===
```{r}
n <- 5
a_int <- integer(n)
a_int
```
```{r}
a_double <- double(n)
a_double

```
```{r}
a_char <- character(n)
a_char

```
```{r}
a_logical <- logical(n)
a_logical
```


A sequence
===
```{r}
a <- seq(from=10, to=100, by=2)
a
b <- seq(from=10, to=100, length=10)
b
c <- rep('a', 4)
c
```



Random number generator
===
- Random numbers from normal distribution
```{r}
set.seed(32611) ## set a seed number such that the random numbers will keep the same
rnorm(n = 5, mean = 0, sd = 1)
```
- mean and sd parameter can also be vectorized.
```{r}
set.seed(32611)
rnorm(n = 5, mean = 0:4, sd = 1)
```
- Random numbers from 1:10
```{r}
set.seed(32611)
sample(1:10,1)
```
- Random numbers from Uniform distribution U(0,1)
```{r}
set.seed(32611)
runif(n = 4)
```

replicate
===
- replicate empty list
```{r}
replicate(4,list())
```
- a complicate example by replicate
```{r}
replicate(5, runif(sample(1:5,1)))
```


Matrix calculation
===
```{r}
a <- matrix(1:6,nrow=3,ncol=2)
a ## matrix will be filled by column by default. 
b <- matrix(6:1, nrow=3, ncol=2)
a * b ## similar to vector, matrix algebra will be done element-wise.
a + c(1,2,3) ## if a matrix add a vector, add by column
```





apply function: works on margins of a matrix (1)
===
```{r}
a <- matrix(1:6,nrow=3,ncol=2)
a
apply(a,1,sum) ## for each row, equivalent to rowSums
apply(a,1,var) ## for each row, calculate the variance
apply(a,1,function(x) x^2) ## can also use an anonymous function, note that R will always fill the result by column.
```


apply function: works on margins of a matrix (2)
===
```{r}
apply(a,2,sum) ## for each column, equivalent to colSums
colSums(a)
apply(a,2,mean) ## for each column, equivalent to colMeans
apply(a,2,function(x) min(x)) ## equivalent to apply(a,2,min)
apply(a,2,min)
```


lapply()
===
- lapply will apply a function to each element of a list
- lapply() is written in C for performance, 
- a simple R implementation that does the same thing:
```{r}
lapply2 <- function(x, f, ...){
  out <- vector("list", length(x))
  for(i in seq_along(x)){
    out[[i]] <- f(x[[i]], ...)
  }
  out
}
l <- list(c(1:10), list(a='a'), c("dog","cat","gator"))
unlist(lapply(l, length))
unlist(lapply2(l, length))
```


lapply usages
===
```{r}
alist <- list(a = 25, b = 100, c = 64)
```
- loop over the elements: for (x in xs)
```{r}
lapply(alist, function(x) sqrt(x))
```
- loop over the numeric indices: for (i in seq_along(xs))
```{r}
lapply(seq_along(alist), function(x) sqrt(alist[[x]]))
```
- loop over the names: for (nm in names(xs))
```{r}
lapply(names(alist), function(x) sqrt(alist[[x]]))
```


lapply on data.frame
===
- data.frame shares the property of a list and a matrix
```{r}
aframe <- data.frame(col1=1:3,col2=4:6)
lapply(aframe, mean) ## as a list
apply(aframe, 2, mean) ## as a matrix

```



sapply() and vapply()
===
- Sapply() is similar to lapply except they simplify the output to produce an atomic vector.
```{r}
aframe <- data.frame(col1=1:3,col2=4:6)
sapply(aframe, sum) ## if not the same atomic type, will coerce to a list
```
- vapply() is simimar to sapply but takes an additional argument specifying the output type.
```{r}
aframe <- data.frame(col1=1:3,col2=4:6)
vapply(aframe, sum, numeric(1)) ## if not logical(1), will coerce to the most appropriate type
```


Multiple inputs (Map)
===
- Map(): handle when more than only one arguments of the function varies.
- question: how to calculated weight mean?
```{r}
xs <- replicate(3, runif(4),simplify=FALSE) ## simplify = TRUE (default) will convert a list to matrix whenever possible
ws <- replicate(3, rnorm(4, 1) + 1,simplify=FALSE)
xs

ws
```

---

- approach 1
```{r}
unlist(lapply(seq_along(xs), function(i){
  weighted.mean(xs[[i]], ws[[i]])
}))
```
- approach 2
```{r}
unlist(Map(weighted.mean,xs,ws))
```
- extra argument
```{r}
unlist(Map(function(x,w) weighted.mean(x, w, na.rm=TRUE),xs, ws))
```


Vectorize 
===
- if your function has to take a scaler as input, you can vectorize it by vectorize function
```{r}
combn(4,2) ## all combinations of "choose 2 numbers from 1:4"
## However, you cannot do combn(4:5,2:3), how to vectorize this function

combnV <- Vectorize(function(x, m) combn(x, m),
                    vectorize.args = c("x", "m"))

combnV(4:5,2:3)
```


balance between efficiency and simplicity of your code
===
- If looping is very time-consuming relative to the actual operation, you may need to consider vectorized calculation to improve efficiency.
- If looping is ignorable comparing to the actual operation (e.g. Gibbs sampling), you can keep your loop to make it readible.

